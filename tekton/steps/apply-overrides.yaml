apiVersion: tekton.dev/v1beta1
kind: StepAction
metadata:
  name: apply-overrides
spec:
  description: >-
    Given some overrides, update a yaml file.

  params:
    - name: inputYaml
      type: string
      default: ""
    - name: overrides
      type: string
      default: ""

  env:
    - { name: INPUT_YAML, value: "$(params.inputYaml)" }
    - { name: OVERRIDES, value: "$(params.overrides)" }
    - { name: TEKTON_RESULT_PATH, value: "$(step.results.merged-values.path)" }

  image: python:3.11-slim
  script: |
    #!/usr/bin/env sh
    set -euo pipefail

    pip install --no-cache-dir pyyaml >/dev/null

    # write inputYaml to a file
    printf "%s" "${INPUT_YAML}" > /workspace/input.yaml
    echo ">>> inputYaml is:"
    cat /workspace/input.yaml

    # write overrides to a file
    printf "%s" "${OVERRIDES}" > /workspace/overrides.txt
    echo ">>> overrides are:"
    cat /workspace/overrides.txt

    # write python program to a file
    cat > /workspace/apply_overrides.py <<'PY'
    #!/usr/bin/env python3
    import argparse
    import sys
    import re
    from typing import Any, Dict, List, Tuple, Optional

    try:
        import yaml
    except ImportError:
        sys.stderr.write("ERROR: PyYAML is required (pip install pyyaml)\n")
        sys.exit(1)

    # ---------- Parsing helpers (fixed) ----------

    def find_assignment_index(s: str) -> int:
        depth = 0
        in_squote = False
        in_dquote = False
        i = 0
        while i < len(s):
            ch = s[i]
            if ch == '\\' and i + 1 < len(s) and (in_squote or in_dquote):
                i += 2
                continue
            if not in_squote and not in_dquote:
                if ch == '[':
                    depth += 1
                elif ch == ']':
                    depth = max(0, depth - 1)
                elif ch == '=' and depth == 0:
                    return i
                elif ch == '"':
                    in_dquote = True
                elif ch == "'":
                    in_squote = True
            else:
                if in_dquote and ch == '"':
                    in_dquote = False
                elif in_squote and ch == "'":
                    in_squote = False
            i += 1
        return -1

    def split_outside_brackets(s: str, sep: str='.') -> List[str]:
        parts: List[str] = []
        buf: List[str] = []
        depth = 0
        in_squote = False
        in_dquote = False
        i = 0
        while i < len(s):
            ch = s[i]
            if ch == '\\' and i + 1 < len(s) and (in_squote or in_dquote):
                buf.append(ch); buf.append(s[i+1])
                i += 2
                continue
            if not in_squote and not in_dquote:
                if ch == '[':
                    depth += 1
                elif ch == ']':
                    depth = max(0, depth - 1)
                elif ch == '"':
                    in_dquote = True
                elif ch == "'":
                    in_squote = True
                elif ch == sep and depth == 0:
                    parts.append(''.join(buf)); buf = []
                    i += 1
                    continue
            else:
                if in_dquote and ch == '"':
                    in_dquote = False
                elif in_squote and ch == "'":
                    in_squote = False
            buf.append(ch); i += 1
        parts.append(''.join(buf))
        return parts

    # --- Segment parsing that supports quoted names ---
    def _decode_escapes(s: str) -> str:
        """Decode simple backslash escapes inside quoted names."""
        out = []
        i = 0
        while i < len(s):
            if s[i] == '\\' and i + 1 < len(s):
                out.append(s[i+1])
                i += 2
            else:
                out.append(s[i])
                i += 1
        return ''.join(out)

    def parse_segment(seg: str) -> Tuple[str, Optional[Dict[str, Any]]]:
        """
        Parse a single path segment which may be:
            - unquoted:   name            or  name[key=value,...]
            - double/single-quoted: "a.b" or  'a.b'  (optionally followed by [key=val,...])
        Returns (name, conditions_dict_or_None)
        """
        seg = seg.strip()
        if not seg:
            raise ValueError("Empty path segment")

        # Quoted name?
        if seg[0] in ('"', "'"):
            q = seg[0]
            i = 1
            buf = []
            while i < len(seg):
                ch = seg[i]
                if ch == '\\' and i + 1 < len(seg):
                    buf.append(seg[i+1])
                    i += 2
                    continue
                if ch == q:
                    i += 1
                    break
                buf.append(ch)
                i += 1
            else:
                raise ValueError(f"Unterminated quoted segment: {seg}")

            name = ''.join(buf)
            rest = seg[i:].strip()

            conds = None
            if rest:
                if not (rest.startswith('[') and rest.endswith(']')):
                    raise ValueError(f"Invalid path segment (unexpected content after quoted name): {seg}")
                conds = parse_conditions(rest[1:-1])
            return name, conds

        # Unquoted (original behavior)
        m = re.fullmatch(r'(?P<name>[^.\[\]]+)(?:\[(?P<conds>[^\]]+)\])?', seg)
        if not m:
            raise ValueError(f"Invalid path segment: {seg}")
        name = m.group('name').strip()
        conds_raw = m.group('conds')
        conds = parse_conditions(conds_raw) if conds_raw else None
        return name, conds

    def parse_conditions(cond_str: str) -> Dict[str, Any]:
        parts = re.split(r'\s*(?:,|&&)\s*', cond_str.strip())
        conds: Dict[str, Any] = {}
        for p in parts:
            if not p:
                continue
            if '=' not in p:
                raise ValueError(f"Invalid condition (expected key=value): {p}")
            k, v = p.split('=', 1)
            k = k.strip()
            v = v.strip()
            if (v.startswith('"') and v.endswith('"')) or (v.startswith("'") and v.endswith("'")):
                v_unquoted = v[1:-1]
            else:
                v_unquoted = v
            try:
                v_parsed = yaml.safe_load(v_unquoted)
            except Exception:
                v_parsed = v_unquoted
            conds[k] = v_parsed
        return conds

    def parse_rule(rule: str) -> Tuple[List[Tuple[str, Optional[Dict[str, Any]]]], str]:
        idx = find_assignment_index(rule)
        if idx == -1:
            raise ValueError("No assignment operator '=' found outside selectors/quotes")
        lhs = rule[:idx]
        rhs = rule[idx+1:]

        raw_segments = split_outside_brackets(lhs)
        segments: List[Tuple[str, Optional[Dict[str, Any]]]] = []
        for seg in raw_segments:
            name, conds = parse_segment(seg)
            segments.append((name, conds))
        return segments, rhs

    # ---------- Data helpers ----------

    def is_list_of_scalars(lst: List[Any]) -> bool:
        return all(isinstance(x, (str, int, float, bool)) or x is None for x in lst)

    def ensure_list_of_dicts(parent: Dict[str, Any], key: str) -> List[Dict[str, Any]]:
        v = parent.get(key)
        if v is None or not isinstance(v, list):
            parent[key] = []
            return parent[key]
        if any(not isinstance(x, dict) for x in v):
            raise TypeError(f"Expected list of objects at '{key}', found non-object entries.")
        return v  # type: ignore

    def select_or_create_in_list(lst: List[Dict[str, Any]], conds: Dict[str, Any]) -> Dict[str, Any]:
        for item in lst:
            if all(item.get(k) == v for k, v in conds.items()):
                return item
        new_item = dict(conds)
        lst.append(new_item)
        return new_item

    def upsert_scalar_list(lst: List[Any], desired: str):
        if '=' in desired:
            prefix = desired.split('=', 1)[0] + '='
            for i, s in enumerate(lst):
                if isinstance(s, str) and s.startswith(prefix):
                    lst[i] = desired
                    return
            lst.append(desired)
        else:
            if desired not in lst:
                lst.append(desired)

    def set_value(target_parent: Dict[str, Any], key: str, rhs: str):
        try:
            parsed = yaml.safe_load(rhs)
        except Exception:
            parsed = rhs
        target_parent[key] = parsed

    # ---------- Rule applier (fixed traversal) ----------

    def apply_rule(doc: Dict[str, Any], rule: str):
        segments, rhs = parse_rule(rule)

        cur: Any = doc
        for idx, (name, conds) in enumerate(segments):
            is_last = (idx == len(segments) - 1)

            if conds is not None:
                # selector: ensure list at this key and select/create the object
                if not isinstance(cur, dict):
                    raise TypeError(f"Expected dict to access '{name}[...]' but found {type(cur).__name__}")
                lst = ensure_list_of_dicts(cur, name)
                cur = select_or_create_in_list(lst, conds)
                continue

            if is_last:
                if not isinstance(cur, dict):
                    raise TypeError(f"Cannot set field '{name}' on non-dict of type {type(cur).__name__}")
                existing = cur.get(name, None)
                if isinstance(existing, list):
                    if is_list_of_scalars(existing) or len(existing) == 0:
                        desired = rhs if isinstance(rhs, str) else str(rhs)
                        upsert_scalar_list(existing, desired)
                    else:
                        raise TypeError(f"Target '{name}' is a list but not of scalars; refusing to overwrite.")
                elif existing is None:
                    if name in ("args", "command",):
                        cur[name] = []
                        upsert_scalar_list(cur[name], rhs)
                    else:
                        set_value(cur, name, rhs)
                else:
                    set_value(cur, name, rhs)
                return

            # Intermediate plain segment: always ensure a dict
            if not isinstance(cur, dict):
                raise TypeError(f"Expected dict to access '{name}' but found {type(cur).__name__}")
            v = cur.get(name)
            if v is None or not isinstance(v, dict):
                cur[name] = {}
            cur = cur[name]

    # ---------- CLI ----------

    def main():
        ap = argparse.ArgumentParser(description="Upsert Helm values using simple rules.")
        ap.add_argument("-i", "--in", dest="input", default="-", help="Input values YAML file (default: stdin)")
        ap.add_argument("-o", "--out", dest="output", default="-", help="Output YAML file (default: stdout)")
        ap.add_argument("-r", "--rule", action="append", dest="rules", default=[], help="Rule to apply (can be repeated)")
        ap.add_argument("-R", "--rules-file", dest="rules_file", help="File with one rule per line")
        args = ap.parse_args()

        # Load input YAML
        data_stream = sys.stdin if args.input == "-" else open(args.input, "r", encoding="utf-8")
        try:
            doc = yaml.safe_load(data_stream) or {}
        finally:
            if args.input != "-":
                data_stream.close()

        # Load rules
        rules: List[str] = list(args.rules)
        if args.rules_file:
            with open(args.rules_file, "r", encoding="utf-8") as rf:
                for line in rf:
                    s = line.strip()
                    if not s or s.startswith("#"):
                        continue
                    rules.append(s)

        if not rules:
            sys.stderr.write("No rules provided. Nothing to do.\n")
            sys.exit(0)

        # Apply rules in order
        for rule in rules:
            try:
                apply_rule(doc, rule)
            except Exception as e:
                sys.stderr.write(f"ERROR applying rule [{rule}]: {e}\n")
                sys.exit(2)

        # Write output
        out_stream = sys.stdout if args.output == "-" else open(args.output, "w", encoding="utf-8")
        try:
            yaml.safe_dump(doc, out_stream, sort_keys=False, width=float("inf"))
        finally:
            if args.output != "-":
                out_stream.close()

    if __name__ == "__main__":
        main()
    PY
    chmod +x /workspace/apply_overrides.py

    # Run the merge
    /workspace/apply_overrides.py \
        -i /workspace/input.yaml \
        -R /workspace/overrides.txt \
        -o /workspace/output.yaml

    # log the merged yaml file
    echo ">>> resulting output.yaml:"
    cat /workspace/output.yaml
